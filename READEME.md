# Monorepo架构
mono的意思是single, repo即repository
Monorepo指的是一个代码仓库中管理多个项目
这个项目是一个基于TypeScript的Monorepo项目，实现报名登记业务,主要用于学习Monorepo架构

### 代码仓库发展历程

1.Single-repo: 即所有应用的项目代码全部放在一个代码仓库中管理, 模块之间仅仅通过简单的划分或不划分来进行组织。
整个应用就像是一个独立的npm包，只在根目录有一个package.json文件，用于管理所有项目的版本和依赖关系。这种方法通常适用于Monolith（巨石）应用，即整个应用作为一个整体进行开发和管理
EG: Vue2

2.Mutirepo: 即多代码仓库，是一种把应用内的各模块彻底隔离和封装的方法，每个模块都存放在一个独立的代码仓库中进行管理。
通常，每一个代码仓库都有独立的版本号管理，依赖管理，CI/CD流程
比如Fasify 每一个Fastify的子模块都有独立的版本号。实际上，每一个子模块都有一个独立的GitHub仓库链接地址，维护相对独立，也有独立的package.json文件管理。每一个子模块的目录结构如下

3.Monorepo: 简单来说就是一个代码仓库中组织多个相隔离的模块代码，可以同时有一个或多个应用.
虽然Monorepo和Single-repo都是把一个应用的所有代码放在一个仓库，但是两者有一个本质区别，即Monorepo项目中的各个子项目与Multirepo一样，要进行彻底的隔离和封装。对于一个特定的子项目来说，这个项目是一个完备的npm包，有独立且完整的package.json文件，可以像Multirepo一样进行独立的版本号管理、依赖管理和CI/CD流程。但是因为所有代码在一个仓库内，物理上在一个文件夹之下，可以很容易进行优化。
比如Vue3
packages目录下的每一个目录都是一个完备的npm包，并且统一进行版本管理。通过比对Vue 3和Vue 2的目录结构，可以看出Vue 3在复杂度和解耦度方面比Vue 2有了很大提升。当然一个项目的代码存储架构不是一成不变的，可以根据成长阶段，选用合适的代码存储架构，甚至可以多种架构组合使用

4.Monorepo的优点
  1.有助于更好，更高效的工作流程
  2.更容易管理应用内部之间的依赖关系
  3.提供统一的Git commit视图
  4.统一CI/CD，打包自动化构建和测试
  5.简化依赖管理
  6.降低多技术融合成本

### FULL-STACK Monorepo的设计原则
1.从Single-repo -> Monorepo
2.明确划分不同技术栈定位
3.应用层类型协议与JSON Schema
使用TypeScript作为核心技术栈可以为前后端在开发时提供类型，JSON Schema可以作为运行时的约束。同时提供运行时和编译时约束，可以提高前后端代码的健壮性和可维护性。
4.最小配置，统一尽可能严格的标准。
维护Monorepo中一个非常耗费精力的工作是配置管理，越少的配置，维护的成本越低。通过创建一个npm包来管理统一配置，并建立严格的代码检查规则(lint)来约束整个代码库，可以有效降低维护成本。在构建良好的Monorepo项目中，随着基础设施的完善，团队的开发效率会不断提高，严格的标准有助于管理日益庞大的代码库。
5.每一个子项目都视为独立的项目


### Deno
Deno的特点
1.原生TS支持
2.仅仅支持ESM模块解析
3.增强包管理机制
Deno中没有包管理的概念。因为Deno支持ESM模块规范，使用import/export语法，外部模块的导入方式与本地模块完全相同，不需要node_modules文件或是如npm或Yarn之类的包管理工具。但是如果所有的依赖项都被单独导入，那么后续维护模块将变得非常麻烦和耗时。Deno的解决方案是分别创建deps.ts和dev_deps.ts文件用于集中引用必需的依赖（对应package.json中dependencies）和开发依赖（对应package.json中devDependencies）​，并重新导出。